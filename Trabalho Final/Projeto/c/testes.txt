// Type your code here, or load an example.
#define VGA_ADDRESS 0xFF000000

void faster_rectangle(int color, int x_lower,
 int y_lower, int x_upper, int y_upper){
    
    unsigned char *Frame, *aux;
	Frame = (unsigned char *) VGA_ADDRESS;


    for (int i = x_lower; i <= x_upper; i++){
        for (int j = y_lower; j <= y_upper; j++){
            aux = Frame + (i + j*320);
	        *aux = color;
        }
    }

}


//////////////////////////////////


// Type your code here, or load an example.
#define VGA_ADDRESS 0xFF000000

void faster_rectangle(char color, int x_lower,
 int y_lower, int x_upper, int y_upper){
    
    //unsigned char *Frame, *aux;
    unsigned int *Frame_faster, *aux_faster;
    
    int new_color = color;
    new_color += new_color << 8;
    new_color += new_color << 16;

	//Frame = (unsigned char *) VGA_ADDRESS;
    Frame_faster = (unsigned int *) VGA_ADDRESS;

    int rem_lower = x_lower + (-x_lower % 5), rem_upper = x_upper % 5;


    //for (int i = x_lower; i < rem_lower; i++){
    //    for (int j = y_lower; j <= y_upper; j++){
    //        aux = Frame + (i + j*320);
	//        *aux = color;
    //    }
    //}


        aux_faster = Frame_faster+x_lower;
	    *aux_faster = new_color;
   

    //for (int i = x_upper-rem_upper+1; i <= x_upper+rem_upper; i++){
    //    for (int j = y_lower; j <= y_upper; j++){
    //        aux = Frame + (i + j*320);
    //        *aux = color;
    //    }
    //}

}

////////////////////// life bar

#define VGA_ADDRESS 0xFF000000

void bar(int color, int x,
 int y, int perc, int width, int height){
    
    unsigned char *Frame, *aux;
	Frame = (unsigned char *) VGA_ADDRESS;


    for (int i = x; i < x + (perc*width)/100; i++){
        for (int j = y; j < y+height; j++){
            aux = Frame + (i + j*320);
	        *aux = color;
        }
    }

}

////////////////////// intersc

// Hitbox format
// (xi, yi), (xf, yf), xi <= xf && yi <= yf 

bool doOverlap(int rect1[], int rect2[])
{
    // l1.x = rect1[0], l1.y = rect1[1]
    // r1.x = rect1[2], r1.y = rect1[3]

    // l2.x = rect2[0], l2.y = rect2[1]
    // r2.x = rect2[2], r2.y = rect2[3]

    // If one rectangle is on left side of other
    if (rect1[0] > rect2[2] || rect2[0] > rect1[2])
        return false;

    // If one rectangle is above other
    if (rect1[3] < rect2[1] || rect2[3] < rect1[1])
        return false;

    return true;
}


void new_position(int player_hb[], int hitbox[],
 int position[], float real_position[]){

    int x_diff = position[0]-position[2],
        y_diff = position[1]-position[3];

    if (y_diff == 0){
        if (x_diff > 0){
            position[0] -= player_hb[2]-hitbox[0] +1;
            real_position[0] -= player_hb[2]-hitbox[0] +1;
        }
        
        else if (x_diff < 0){
            position[0] -= player_hb[0]-hitbox[2] -1;
            real_position[0] -= player_hb[0]-hitbox[2] -1;
        }

        return;
        
        
    }
    
    if (y_diff > 0){
        position[1] -= player_hb[3]-hitbox[1]+1;
        real_position[1] -= player_hb[3]-hitbox[1]+1;
        return;
    }
    position[1] -= player_hb[1]-hitbox[3]-1;
    real_position[1] -= player_hb[1]-hitbox[3]-1;
 
}

// Hitbox Section format
// num_of_hbs, (interaction_type, Hitbox format)*


void player_hitbox_interaction(int *player_hb, int *hitbox_section,
 int position [], float real_position[]){

    int n = *hitbox_section;
    int interaction_type;
    bool did_collide;

    hitbox_section++;

    for (int i = 0; i < n; i++){
        
        interaction_type = *hitbox_section;
        hitbox_section++;

        did_collide = doOverlap(player_hb, hitbox_section);

        if (interaction_type == 2){
            hitbox_section += 4;
        }

        if (did_collide){

            switch(interaction_type){
                case 1:
                    new_position(player_hb, hitbox_section, position, real_position);
                    break;

                case 2:
                    int new_bg = *(hitbox_section), new_hb = *(hitbox_section+1),
                        new_x = *(hitbox_section+2), new_y = *(hitbox_section+3);

                    new_y -= position[1];

                    position[1] += new_y;

                    real_position[1] += (float)new_y;

                    if (new_x != 0){
                        new_x -= position[0];
                        position[0] += new_x;
                        real_position[0] += (float)new_x;
                    }

                    asm("sw %0,24(sp)\n\tsw %1,20(sp)" :: "r" (new_bg), "r" (new_hb));
                
                    break;

            }

            /*asm ("addi sp,sp,-4\n\tsw a0,0(sp)\n\t"
                 "mv a0,%0 \n\tli a7, 1\n\tecall\n\t"
                 "lw a0,0(sp)\n\taddi sp,sp,4" :: "r" (interaction_type));
            */
        }

        /*else{
            asm ("addi sp,sp,-4\n\tsw a0,0(sp)\n\t"
                 "li a0,-1 \n\tli a7, 1\n\tecall\n\t"
                 "lw a0,0(sp)\n\taddi sp,sp,4");

        }*/

        hitbox_section += 4;
    }

}

/////////////////// print char

char print_char(char a0, int a1, int a2, int a3, bool a4){
    return a0+(char)a1;
}

int text_box(int *name, int current_index, 
int x, int y, int max_letters, int max_lines) {

    char *pointer = (char *)(name+1);
 
    for (int i = 0; i < max_lines; i++){
        for (int j = 0; j < max_letters; j++){
            if (current_index > *name){
                break;
            }
            print_char(*pointer, x, y, 111, false);
            pointer++;
            current_index++;
        }
    }

    return current_index;
}


